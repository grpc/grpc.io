

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="/css/style.css">
    <title>
  Asynchronous Basics - C&#43;&#43; &ndash; gRPC
</title>

		
		<link rel="apple-touch-icon" href="/favicons/apple-touch-icon.png" sizes="180x180">
		<link rel="icon" type="image/png" href="/favicons/android-chrome-192x192.png" sizes="192x192" >
		<link rel="icon" type="image/png" href="/favicons/favicon-32x32.png" sizes="32x32">
		<link rel="icon" type="image/png" href="/favicons/favicon-16x16.png" sizes="16x16">
		<link rel="manifest" href="/favicons/manifest.json">
		<link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#2DA6B0">
		<meta name="msapplication-TileColor" content="#ffffff">
		<meta name="msapplication-TileImage" content="/favicons/mstile-150x150.png">

    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-60127042-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-60127042-1');
    </script>

  </head>
  <body>
    <div id="landing-content">
      <div class="row">
        <div class="topbannersub">
          <nav class="navbar navbar-expand-md navbar-dark topnav">
            <a class="navbar-brand" href="https://cjyabraham.github.io/">
              <img src="https://cjyabraham.github.io/img/grpc-logo.png" width="114" height="50">
            </a>

            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
              <span class="navbar-toggler-icon"></span>
            </button>

            <div class="topnav, collapse navbar-collapse" id="navbarSupportedContent" style="float:right !important">
              <ul class="navbar-nav ml-auto">
                <li class="nav-item ">
                  <a class="nav-link" href="https://cjyabraham.github.io/about/">About</a>
                </li>
                <li class="nav-item dropdown active">
                  <a class="nav-link dropdown-toggle" href="https://cjyabraham.github.io/docs/" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                    Docs
                  </a>

                  <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                    
                    
                    <a class="dropdown-item" href="/docs">
                      Overview
                    </a>
                    
                    
                    <a class="dropdown-item" href="/docs/quickstart/">
                      Quick Start
                    </a>
                    
                    
                    <a class="dropdown-item" href="/docs/guides/">
                      Guides
                    </a>
                    
                    
                    <a class="dropdown-item" href="/docs/tutorials/">
                      Tutorials
                    </a>
                    
                    
                    <a class="dropdown-item" href="/docs/reference/">
                      Reference
                    </a>
                    
                    
                    <a class="dropdown-item" href="/docs/samples/">
                      Samples
                    </a>
                    
                    
                    <a class="dropdown-item" href="/docs/talks">
                      Presentations
                    </a>
                    
                  </div>
                </li>
                <li class="nav-item ">
                  <a class="nav-link" href="/blog">
                    Blog
                  </a> 
                </li>
                <li class="nav-item ">
                  <a class="nav-link" href="/community">Community</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="https://packages.grpc.io/">
                    Packages
                  </a> 
                </li>
                <li class="nav-item ">
                  <a class="nav-link" href="https://cjyabraham.github.io/faq/">FAQ</a>
                </li>
              </ul>
            </div>
          </nav>
          
          
            <div class="headertext">Documentation</div>
  </div>
        </div>
        </div>

    <div class="subnav d-none d-md-block">
  <a href="https://cjyabraham.github.io/docs/" >Overview</a>
|  <a href="https://cjyabraham.github.io/docs/quickstart/" >Quick Start</a>
|  <a href="https://cjyabraham.github.io/docs/guides/" >Guides</a>
|  <a href="https://cjyabraham.github.io/docs/tutorials/"  class="active">Tutorials</a>
|  <a href="https://cjyabraham.github.io/docs/reference/" >Reference</a>
|  <a href="https://cjyabraham.github.io/docs/samples/" >Samples</a>
|  <a href="https://cjyabraham.github.io/docs/talks/" >Presentations</a>
</div>


<div class="quickstartcols">

<div class="quickstartcol1">

<h8>Tutorials</h8>
<a href="https://cjyabraham.github.io/docs/tutorials/async/helloasync-cpp/" class="active">Async - C++</a>
<a href="https://cjyabraham.github.io/docs/tutorials/auth/oauth2-objective-c/" >Auth - Objective C</a>
<h8>Basic</h8>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/c/" >C++</a>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/csharp/" >C#</a>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/dart/" >Dart</a>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/go/" >Go</a>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/java/" >Java</a>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/android/" >Android Java</a>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/node/" >Node</a>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/objective-c/" >Objective-C</a>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/php/" >PHP</a>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/python/" >Python</a>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/ruby/" >Ruby</a>
<a href="https://cjyabraham.github.io/docs/tutorials/basic/web/" >Web</a>

</div>

<div class="quickstartcol2" style="margin-top:4%">
<h3 style="margin-top:0px;">Asynchronous Basics - C&#43;&#43;</h3>

    

<p>This tutorial shows you how to write a simple server and client in C++ using
gRPC&rsquo;s asynchronous/non-blocking APIs. It assumes you are already familiar with
writing simple synchronous gRPC code, as described in <a href="/docs/tutorials/basic/c/">gRPC Basics:
C++</a>. The example used in this tutorial follows on
from the basic <a href="https://github.com/grpc/grpc/tree/v1.20.0/examples/cpp/helloworld">Greeter example</a> we used in the
<a href="/docs/">overview</a>. You&rsquo;ll find it along with installation
instructions in
<a href="https://github.com/grpc/grpc/tree/v1.20.0/examples/cpp/helloworld">grpc/examples/cpp/helloworld</a>.</p>

<div id="toc"></div>

<h3 id="overview">Overview</h3>

<p>gRPC uses the
<a href="/grpc/cpp/classgrpc_1_1_completion_queue.html"><code>CompletionQueue</code></a>
API for asynchronous operations. The basic work flow
is as follows:</p>

<ul>
<li>bind a <code>CompletionQueue</code> to an RPC call</li>
<li>do something like a read or write, present with a unique <code>void*</code> tag</li>
<li>call <code>CompletionQueue::Next</code> to wait for operations to complete. If a tag
appears, it indicates that the corresponding operation is complete.</li>
</ul>

<h3 id="async-client">Async client</h3>

<p>To use an asynchronous client to call a remote method, you first create a
channel and stub, just as you do in a <a href="https://github.com/grpc/grpc/blob/v1.20.0/examples/cpp/helloworld/greeter_client.cc">synchronous
client</a>. Once you have your stub, you do
the following to make an asynchronous call:</p>

<ul>
<li>Initiate the RPC and create a handle for it. Bind the RPC to a
<code>CompletionQueue</code>.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">    CompletionQueue cq;
    std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>ClientAsyncResponseReader<span style="color:#f92672">&lt;</span>HelloReply<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> rpc(
        stub_<span style="color:#f92672">-&gt;</span>AsyncSayHello(<span style="color:#f92672">&amp;</span>context, request, <span style="color:#f92672">&amp;</span>cq));</code></pre></div>
<ul>
<li>Ask for the reply and final status, with a unique tag</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">    Status status;
    rpc<span style="color:#f92672">-&gt;</span>Finish(<span style="color:#f92672">&amp;</span>reply, <span style="color:#f92672">&amp;</span>status, (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#ae81ff">1</span>);</code></pre></div>
<ul>
<li>Wait for the completion queue to return the next tag. The reply and status are
ready once the tag passed into the corresponding <code>Finish()</code> call is returned.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">    <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> got_tag;
    <span style="color:#66d9ef">bool</span> ok <span style="color:#f92672">=</span> false;
    cq.Next(<span style="color:#f92672">&amp;</span>got_tag, <span style="color:#f92672">&amp;</span>ok);
    <span style="color:#66d9ef">if</span> (ok <span style="color:#f92672">&amp;&amp;</span> got_tag <span style="color:#f92672">==</span> (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#ae81ff">1</span>) {
      <span style="color:#75715e">// check reply and status
</span><span style="color:#75715e"></span>    }</code></pre></div>
<p>You can see the complete client example in
<a href="https://github.com/grpc/grpc/blob/v1.20.0/examples/cpp/helloworld/greeter_async_client.cc">greeter&#95;async&#95;client.cc</a>.</p>

<h3 id="async-server">Async server</h3>

<p>The server implementation requests an RPC call with a tag and then waits for the
completion queue to return the tag. The basic flow for handling an RPC
asynchronously is:</p>

<ul>
<li>Build a server exporting the async service</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">    helloworld<span style="color:#f92672">::</span>Greeter<span style="color:#f92672">::</span>AsyncService service;
    ServerBuilder builder;
    builder.AddListeningPort(<span style="color:#e6db74">&#34;0.0.0.0:50051&#34;</span>, InsecureServerCredentials());
    builder.RegisterAsyncService(<span style="color:#f92672">&amp;</span>service);
    <span style="color:#66d9ef">auto</span> cq <span style="color:#f92672">=</span> builder.AddCompletionQueue();
    <span style="color:#66d9ef">auto</span> server <span style="color:#f92672">=</span> builder.BuildAndStart();</code></pre></div>
<ul>
<li>Request one RPC, providing a unique tag</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">    ServerContext context;
    HelloRequest request;
    ServerAsyncResponseWriter<span style="color:#f92672">&lt;</span>HelloReply<span style="color:#f92672">&gt;</span> responder;
    service.RequestSayHello(<span style="color:#f92672">&amp;</span>context, <span style="color:#f92672">&amp;</span>request, <span style="color:#f92672">&amp;</span>responder, <span style="color:#f92672">&amp;</span>cq, <span style="color:#f92672">&amp;</span>cq, (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#ae81ff">1</span>);</code></pre></div>
<ul>
<li>Wait for the completion queue to return the tag. The context, request and
responder are ready once the tag is retrieved.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">    HelloReply reply;
    Status status;
    <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> got_tag;
    <span style="color:#66d9ef">bool</span> ok <span style="color:#f92672">=</span> false;
    cq.Next(<span style="color:#f92672">&amp;</span>got_tag, <span style="color:#f92672">&amp;</span>ok);
    <span style="color:#66d9ef">if</span> (ok <span style="color:#f92672">&amp;&amp;</span> got_tag <span style="color:#f92672">==</span> (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#ae81ff">1</span>) {
      <span style="color:#75715e">// set reply and status
</span><span style="color:#75715e"></span>      responder.Finish(reply, status, (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#ae81ff">2</span>);
    }</code></pre></div>
<ul>
<li>Wait for the completion queue to return the tag. The RPC is finished when the
tag is back.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">    <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> got_tag;
    <span style="color:#66d9ef">bool</span> ok <span style="color:#f92672">=</span> false;
    cq.Next(<span style="color:#f92672">&amp;</span>got_tag, <span style="color:#f92672">&amp;</span>ok);
    <span style="color:#66d9ef">if</span> (ok <span style="color:#f92672">&amp;&amp;</span> got_tag <span style="color:#f92672">==</span> (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#ae81ff">2</span>) {
      <span style="color:#75715e">// clean up
</span><span style="color:#75715e"></span>    }</code></pre></div>
<p>This basic flow, however, doesn&rsquo;t take into account the server handling multiple
requests concurrently. To deal with this, our complete async server example uses
a <code>CallData</code> object to maintain the state of each RPC, and uses the address of
this object as the unique tag for the call.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">  class CallData {
   public:
    <span style="color:#75715e">// Take in the &#34;service&#34; instance (in this case representing an asynchronous
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// server) and the completion queue &#34;cq&#34; used for asynchronous communication
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// with the gRPC runtime.
</span><span style="color:#75715e"></span>    CallData(Greeter<span style="color:#f92672">::</span>AsyncService<span style="color:#f92672">*</span> service, ServerCompletionQueue<span style="color:#f92672">*</span> cq)
        <span style="color:#f92672">:</span> service_(service), cq_(cq), responder_(<span style="color:#f92672">&amp;</span>ctx_), status_(CREATE) {
      <span style="color:#75715e">// Invoke the serving logic right away.
</span><span style="color:#75715e"></span>      Proceed();
    }

    <span style="color:#66d9ef">void</span> Proceed() {
      <span style="color:#66d9ef">if</span> (status_ <span style="color:#f92672">==</span> CREATE) {
        <span style="color:#75715e">// As part of the initial CREATE state, we *request* that the system
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// start processing SayHello requests. In this request, &#34;this&#34; acts are
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// the tag uniquely identifying the request (so that different CallData
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// instances can serve different requests concurrently), in this case
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// the memory address of this CallData instance.
</span><span style="color:#75715e"></span>        service_<span style="color:#f92672">-&gt;</span>RequestSayHello(<span style="color:#f92672">&amp;</span>ctx_, <span style="color:#f92672">&amp;</span>request_, <span style="color:#f92672">&amp;</span>responder_, cq_, cq_,
                                  this);
        <span style="color:#75715e">// Make this instance progress to the PROCESS state.
</span><span style="color:#75715e"></span>        status_ <span style="color:#f92672">=</span> PROCESS;
      } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (status_ <span style="color:#f92672">==</span> PROCESS) {
        <span style="color:#75715e">// Spawn a new CallData instance to serve new clients while we process
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// the one for this CallData. The instance will deallocate itself as
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// part of its FINISH state.
</span><span style="color:#75715e"></span>        new CallData(service_, cq_);

        <span style="color:#75715e">// The actual processing.
</span><span style="color:#75715e"></span>        std<span style="color:#f92672">::</span>string prefix(<span style="color:#e6db74">&#34;Hello &#34;</span>);
        reply_.set_message(prefix <span style="color:#f92672">+</span> request_.name());

        <span style="color:#75715e">// And we are done! Let the gRPC runtime know we&#39;ve finished, using the
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// memory address of this instance as the uniquely identifying tag for
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// the event.
</span><span style="color:#75715e"></span>        responder_.Finish(reply_, Status<span style="color:#f92672">::</span>OK, this);
        status_ <span style="color:#f92672">=</span> FINISH;
      } <span style="color:#66d9ef">else</span> {
        GPR_ASSERT(status_ <span style="color:#f92672">==</span> FINISH);
        <span style="color:#75715e">// Once in the FINISH state, deallocate ourselves (CallData).
</span><span style="color:#75715e"></span>        delete this;
      }
    }
  }</code></pre></div>
<p>For simplicity the server only uses one completion queue for all events, and
runs a main loop in <code>HandleRpcs</code> to query the queue:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">HandleRpcs</span>() {
    <span style="color:#75715e">// Spawn a new CallData instance to serve new clients.
</span><span style="color:#75715e"></span>    new CallData(<span style="color:#f92672">&amp;</span>service_, cq_.get());
    <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> tag;  <span style="color:#75715e">// uniquely identifies a request.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> ok;
    <span style="color:#66d9ef">while</span> (true) {
      <span style="color:#75715e">// Block waiting to read the next event from the completion queue. The
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// event is uniquely identified by its tag, which in this case is the
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// memory address of a CallData instance.
</span><span style="color:#75715e"></span>      cq_<span style="color:#f92672">-&gt;</span>Next(<span style="color:#f92672">&amp;</span>tag, <span style="color:#f92672">&amp;</span>ok);
      GPR_ASSERT(ok);
      static_cast<span style="color:#f92672">&lt;</span>CallData<span style="color:#f92672">*&gt;</span>(tag)<span style="color:#f92672">-&gt;</span>Proceed();
    }
  }</code></pre></div>
<h4 id="shutting-down-the-server">Shutting Down the Server</h4>

<p>We&rsquo;ve been using a completion queue to get the async notifications. Care must be
taken to shut it down <em>after</em> the server has also been shut down.</p>

<p>Remember we got our completion queue instance <code>cq_</code> in <code>ServerImpl::Run()</code> by
running <code>cq_ = builder.AddCompletionQueue()</code>. Looking at
<code>ServerBuilder::AddCompletionQueue</code>&rsquo;s documentation we see that</p>

<blockquote>
<p>&hellip; Caller is required to shutdown the server prior to shutting down the
returned completion queue.</p>
</blockquote>

<p>Refer to <code>ServerBuilder::AddCompletionQueue</code>&rsquo;s full docstring for more details.
What this means in our example is that <code>ServerImpl's</code> destructor looks like:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">  <span style="color:#f92672">~</span>ServerImpl() {
    server_<span style="color:#f92672">-&gt;</span>Shutdown();
    <span style="color:#75715e">// Always shutdown the completion queue after the server.
</span><span style="color:#75715e"></span>    cq_<span style="color:#f92672">-&gt;</span>Shutdown();
  }</code></pre></div>
<p>You can see our complete server example in
<a href="https://github.com/grpc/grpc/blob/v1.20.0/examples/cpp/helloworld/greeter_async_server.cc">greeter&#95;async&#95;server.cc</a>.</p>

</div>
</div>

</div>

          
          

      <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
      <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>

  </body>
</html>
