---
title: Announcing out-of-the-box support for gRPC in the Flatbuffers serialization library
date: 2017-08-17
spelling: cSpell:ignore flatc Oortmerssen Wouter
author:
  name: Wouter van Oortmerssen
  position: Google
---

The recent release of Flatbuffers [version 1.7](https://github.com/google/flatbuffers/releases) introduced truly zero-copy support for gRPC out of the box.

[Flatbuffers](https://google.github.io/flatbuffers/) is a serialization library that allows you to access serialized data without first unpacking it or allocating any
additional data structures. It was originally designed for games and other resource constrained applications, but is now finding more general use, both by teams within Google and in other companies such as Netflix and Facebook.

<!--more-->

Flatbuffers enables maximum throughput by directly using gRPC's slice buffers with zero-copy for common use cases. An incoming rpc can be processed directly from gRPCs internal buffers, and constructing a new message will write directly to these buffers without intermediate steps.

This is currently, fully supported in the C++ implementation of FlatBuffers, with more languages to come. There is also an implementation in Go, which is not entirely zero copy, but still very low on allocation cost (see below).


## Example Usage

Let's look at an example of how this works.

### Use Flatbuffers as an IDL

Start with an `.fbs` schema (similar to .proto, if you are familiar with protocol buffers) that declares an RPC service:

```proto
table HelloReply {
  message:string;
}

table HelloRequest {
  name:string;
}

table ManyHellosRequest {
  name:string;
  num_greetings:int;
}

rpc_service Greeter {
  SayHello(HelloRequest):HelloReply;
  SayManyHellos(ManyHellosRequest):HelloReply (streaming: "server");
}
```

To generate C++ code from this, run: `flatc --cpp --grpc example.fbs`, much like in protocol buffers.

#### Generated Server Implementation
The server implementation is very similar to protocol buffers, except now the request and response messages are of type `flatbuffers::grpc::Message<HelloRequest> *`.
Unlike protocol buffers, where these types represent a tree of C++ objects, here they are merely handles to a flat object in the underlying gRPC slice. You can access the data directly:

```cpp
auto request = request_msg->GetRoot();
auto name = request->name()->str();
```

Building a response is equally simple
```cpp
auto msg_offset = mb_.CreateString("Hello, " + name);
auto hello_offset = CreateHelloReply(mb_, msg_offset);
mb_.Finish(hello_offset);
*response_msg = mb_.ReleaseMessage<HelloReply>();
```

The client code is the same as that generated by protocol buffers, except for the FlatBuffer access and construction code.


See the full example [here](https://github.com/google/flatbuffers/tree/master/grpc/samples/greeter). To compile it, you need gRPC.
The same repo has a [similar example](https://github.com/google/flatbuffers/blob/master/grpc/tests/go_test.go) for Go.

Read more about using and building FlatBuffers for your platform [on the flatbuffers site](https://google.github.io/flatbuffers/).
