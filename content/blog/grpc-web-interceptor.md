---
title: Using gRPC-Web Interceptors
date: 2020-06-01
authors:
- name: Zhenli Jiang
  position: Google
---

Interceptor is a very common pattern for RPC client APIs in many languages. gRPC-Web has also released this feature recently (May 2020 v1.1.0). The current design is based on other gRPCs’ (Java, Node, Go, etc) client interceptors, with some gRPC-Web specific features for better developer experience. Meanwhile, we’ve made a lot of effort to integrate gRPC-Web and the client interceptor design into Google’s internal Web frameworks. We believe that our current design allows gRPC-Web to be easily integrated into modern Web frameworks and the API is also very easy for gRPC-Web users to adopt.

## Introduction
In [gRPC-Web](https://github.com/grpc/grpc-web) there are two kinds of [client interceptors](https://github.com/grpc/grpc-web/blob/master/javascript/net/grpc/web/interceptor.js). The type of interceptors is determined by the response type of the RPC call. 
+ **UnaryInterceptor**: for Promise responses
+ **StreamInterceptor**: for ClientReadableStream responses

gRPC-Web has two clients generated by [Protoc](https://github.com/grpc/grpc-web#client-configuration-options) for one service: let’s say *FooServiceClient* and *FooServicePromiseClient*. The response type of *FooServiceClient* is [ClientReadableStream](https://github.com/grpc/grpc-web/blob/master/javascript/net/grpc/web/clientreadablestream.js) for BOTH unary calls and server streaming calls, so **StreamInterceptor** is expected to be used for intercepting *FooServiceClient* calls. The response type of *PromiseClient* is [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise), so we should use **UnaryInterceptor** for *PromiseClients*.

The design of UnaryInterceptor looks like:
```js
/*
* StreamInterceptor shares the same semantics except the return type of it is
* ClientReadablaStream
* @interface 
*/
const UnaryInterceptor = function() {};

/**
 * @template REQUEST, RESPONSE
 * @param {!Request<REQUEST, RESPONSE>} request
 * @param {function(!Request<REQUEST,RESPONSE>):!Promise<!UnaryResponse<RESPONSE>>}
 *     invoker
 * @return {!Promise<!UnaryResponse<RESPONSE>>}
 */
 
UnaryInterceptor.prototype.intercept = function(request, invoker) {};
```
Unary/StreamInterceptor is designed as an interface with one method to be implemented. A dedicated class for interceptors will have better scalability since we usually want to implement it with some complex functionality. This will also make things a lot easier for gRPC-Web to be embedded in other client platforms.

 The intercept method takes in two parameters:
+ **[grpc.web.Request](https://github.com/grpc/grpc-web/blob/master/javascript/net/grpc/web/request.js)**:  A wrapper class of RequestMessage, MethodDescriptor, Metadata, CallOptions.
+ **Invoker function**: This function will make the actual RPC call and return the response.

Besides grpc.web.Request, we’ve introduced another new class here: 
+ **[grpc.web.UnaryResponse](https://github.com/grpc/grpc-web/blob/master/javascript/net/grpc/web/unaryresponse.js)**:
A wrapper class of response message, status and response metadata, so that we could handle the response metadata(headers) via interceptors.

## Configure interceptors
Currently Interceptors could be configured during client construction by providing an ordered list:
```js
// The option key for configuring UnaryInterceptor is 'unaryInterceptors'
const promiseClient = new FooServicePromiseClient(
    host, creds, {'unaryInterceptors': [interceptor1, interceptor2, interceptor3]});

// The option key for configuring StreamInterceptor is 'streamInterceptors'
const client = new FooServiceClient(
    host, creds, {'streamInterceptors': [interceptor1, interceptor2, interceptor3]});
```

Note that the inbound operations will be executed in the reverse order and the outbound operations are the other way around.  If we have ```[interceptor1, interceptor2, interceptor3]``` during the client construction, the workflow is:
```
  Request   --> Interceptor3 --> Interceptor2 --> Interceptor1 --> Intercepted --> Server
                                                                     Request         |
                                                                                     |
Intercepted <-- Interceptor3 <-- Interceptor2 <-- Interceptor1 <--   Response  <-- Server
 Response  
```


## Example Interceptors
Basically, you may want to do two things with interceptors:  
1. Update the original request, inject extra information such as auth headers.
2. Manipulate the behavior of the original invoker function, such as bypassing the call or updating the response.

### UnaryInterceptor
A very simple example of how to implement the UnaryInterceptor interface:
```js
/**
 * Implement the UnaryInterceptor interface and override the intercept method.
 * @constructor
 * @implements {UnaryInterceptor}
 */
const TestUnaryInterceptor = function() {};

/** @override */
TestUnaryInterceptor.prototype.intercept = function(request, invoker) {
  // Intercept the request by updating the request proto message.
  const reqMsg = request.getRequestMessage();
  reqMsg.setMessage('[Intercept request]' + reqMsg.getMessage());

  // Intercept the response by updating the logic of the invoking function.
  return invoker(request).then((response) => {
    // We could also do something with the response metadata here.
    console.log(response.getMetadata());
    
    // Update the response proto message and return the new response.
    const responseMsg = response.getResponseMessage();
    responseMsg.setMessage('[Intercept response]' + responseMsg.getMessage());
    
    return response;
  });
};
```

### StreamInterceptor
It’s a little bit trickier to intercept the response ClientReadableStream using a StreamInterceptor. The main procedures should be: 
1. Create a new subclass of ClientReadableStream that wraps around the original stream and overrides its methods, so that we could handle its response and update callbacks(listeners).
2. Create a new subclass of StreamInterceptor. While implementing the StreamInterceptor.prototype.intercept method, return the wrapped ClientReadableStream.
3. Apply the instantiated StreamInterceptor during the client construction.

First, create a new subclass of ClientReadableStream:
```js
/**
 * Create a new wrapper stream of the original response stream.
 * @implements {ClientReadableStream}
 * @constructor
 * @param {!ClientReadableStream<RESPONSE>} stream
 * @template RESPONSE
 */
const InterceptedStream = function(stream) {
  this.stream = stream;
};
 /** @override */
InterceptedStream.prototype.on = function(eventType, callback) {
  if (eventType == 'data') {
    const newCallback = (response) => {
      // Intercept the response proto message.
      const msg = response.getMessage();
      response.setMessage('[Intercept response]' + msg);
      // Call the original callback function inside the new callback function.
      callback(response);
    };
    // Set up the new data callback for the new stream.
    this.stream.on(eventType, newCallback);
  } else {
    // Can also override 'status', 'end', 'error' eventType here.
    this.stream.on(eventType, callback);
  }
  return this;
};

/** @override */
InterceptedStream.prototype.cancel = function() {
  this.stream.cancel();
  return this;
};
```

Then in the interceptor, return the new stream:
```js
/**
 * @constructor
 * @implements {StreamInterceptor}
 */
const TestStreamInterceptor = function() {};

/** @override */
TestStreamInterceptor.prototype.intercept = function(request, invoker) {
  return new InterceptedStream(invoker(request));
};
```


### Advanced example: RetryInterceptor:
```js
/**
 * @constructor
 * @implements {StreamInterceptor}
 */
const RetryInterceptor = function() {};

/** @override */
RetryInterceptor.prototype.intercept = function(request, invoker) {
  /**
   * @implements {ClientReadableStream}
   * @constructor
   * @param {!ClientReadableStream<RESPONSE>} stream
   * @param {number} retries
   * @template RESPONSE
   */
  const InterceptedStream = function(stream, retries) {
    this.stream = stream;
    this.retries = retries;
    this.onDataCallback = null;
  };

  /** @override */
  InterceptedStream.prototype.on = function(eventType, callback) {
    if (eventType == 'data') {
      this.onDataCallback_ = callback;
      this.stream.on(eventType, callback);
    } else if (eventType == 'status') {
      const newCallback = (status) => {
        if (this.retries > 0 && status !== StatusCode.OK) {
          const reqMessage = request.getRequestMessage();
          reqMessage.setMessage(`[Retry ${this.retries}]`);
          this.stream.cancel();
          this.stream =
              new InterceptedStream(invoker(request), this.retries - 1);
          this.stream.on('status', callback);
          if (this.onDataCallback_) {
            // Set up the new callback for the new stream.
            this.stream.on('data', this.onDataCallback_);
          }
        } else {
          callback(status);
        }
      };
      this.stream.on(eventType, newCallback);
    }
    return this;
  };

  /** @override */
  InterceptedStream.prototype.cancel = function() {
    this.stream.cancel();
    return this;
  };

  return new InterceptedStream(invoker(request), 3);
};
```

If you have any questions or advice, feel free to contact us on [Github](https://github.com/grpc/grpc-web/issues) or send us an email to grpc-web-team@google.com! 


